<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CRITTERS_SANDBOX_README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CRITTERS_SANDBOX_README.md" />
              <option name="updatedContent" value="# Critters Sandbox Implementation&#10;&#10;## Overview&#10;&#10;This implementation demonstrates how to securely run untrusted player-submitted Critter code using Java's built-in compilation and reflection capabilities with timeout protection.&#10;&#10;## What Was Implemented&#10;&#10;### 1. SecurityHandler.java&#10;Located at: `app/src/main/java/compsci/labs/critters/server/SecurityHandler.java`&#10;&#10;**Features:**&#10;- **In-Memory Compilation**: Compiles Java source code at runtime without writing files to disk&#10;- **Isolated ClassLoaders**: Each critter class is loaded in its own ClassLoader for isolation&#10;- **Timeout Protection**: ExecutorService with timeouts prevents infinite loops (1 second limit)&#10;- **Safe Execution**: Reflection-based execution of critter methods with exception handling&#10;&#10;**Key Classes:**&#10;- `SecurityHandler`: Main entry point for loading and compiling critters&#10;- `SandboxedCritter`: Wrapper that executes critter methods safely&#10;- `CritterExecutionResult`: Return type containing action, color, display string, or error&#10;- `IsolatedClassLoader`: Custom ClassLoader for class isolation&#10;- `InMemoryJavaFile` &amp; `InMemoryFileManager`: Support for in-memory compilation&#10;&#10;### 2. SandboxTestRunner.java&#10;Located at: `app/src/main/java/compsci/labs/critters/server/SandboxTestRunner.java`&#10;&#10;Comprehensive test suite demonstrating:&#10;- Loading custom critters from files&#10;- Executing critter methods safely&#10;- Handling malicious code attempts&#10;- Integration with game loop simulation&#10;&#10;### 3. Test Critter Classes&#10;Located at: `test_critters/`&#10;&#10;- **TestCritter.java**: A normal custom critter that changes color over time&#10;- **MaliciousCritter.java**: Example of potentially dangerous code (safely handled)&#10;&#10;## How to Use&#10;&#10;### Basic Usage&#10;&#10;```java&#10;// Load a critter from a file&#10;Path critterFile = Paths.get(&quot;path/to/CustomCritter.java&quot;);&#10;SecurityHandler.SandboxedCritter sandboxed = &#10;    SecurityHandler.loadCritterFromFile(critterFile);&#10;&#10;// Execute the critter's getMove method&#10;CritterInfo info = ...; // Get from game state&#10;SecurityHandler.CritterExecutionResult result = &#10;    sandboxed.executeGetMove(info);&#10;&#10;if (result.hasError()) {&#10;    // Handle error (timeout, exception, etc.)&#10;    System.err.println(&quot;Critter failed: &quot; + result.error.getMessage());&#10;} else {&#10;    // Use the result&#10;    Critter.Action action = result.action;&#10;    Color color = result.color;&#10;    String display = result.displayString;&#10;}&#10;&#10;// Clean up when done&#10;sandboxed.close();&#10;```&#10;&#10;### Loading from String&#10;&#10;```java&#10;String sourceCode = &quot;&quot;&quot;&#10;    import compsci.labs.critters.server.Critter;&#10;    import compsci.labs.critters.server.CritterInfo;&#10;    import java.awt.Color;&#10;    &#10;    public class MyCustomCritter extends Critter {&#10;        public Action getMove(CritterInfo info) {&#10;            return info.getFront() == Neighbor.EMPTY ? Action.HOP : Action.RIGHT;&#10;        }&#10;        &#10;        public Color getColor() {&#10;            return Color.BLUE;&#10;        }&#10;        &#10;        public String toString() {&#10;            return &quot;C&quot;;&#10;        }&#10;    }&#10;    &quot;&quot;&quot;;&#10;&#10;SecurityHandler.SandboxedCritter sandboxed = &#10;    SecurityHandler.loadCritterClass(sourceCode, &quot;MyCustomCritter&quot;);&#10;```&#10;&#10;## Security Features&#10;&#10;### Current Protections&#10;&#10;1. **Timeout Protection**: Prevents infinite loops (1 second limit per execution)&#10;2. **Isolated ClassLoaders**: Each critter loads in its own namespace&#10;3. **Exception Handling**: All exceptions are caught and returned as errors&#10;4. **In-Memory Compilation**: No file system writes required&#10;&#10;### Limitations (Important!)&#10;&#10;This is a **proof-of-concept** implementation. It does NOT prevent:&#10;&#10;- ❌ File system access&#10;- ❌ Network access  &#10;- ❌ System.exit() calls&#10;- ❌ Thread creation (beyond the timeout thread)&#10;- ❌ Memory exhaustion attacks&#10;- ❌ CPU-intensive operations (within the timeout window)&#10;&#10;### For Production Use&#10;&#10;Consider these additional security measures:&#10;&#10;1. **Process Isolation**: Run each critter in a separate JVM process&#10;2. **Containerization**: Use Docker containers with resource limits&#10;3. **GraalVM Espresso**: Use Java-on-Truffle for true sandboxing&#10;4. **Bytecode Analysis**: Analyze bytecode before execution to detect patterns&#10;5. **SecurityManager**: Enable Java SecurityManager (deprecated but still useful)&#10;6. **Resource Limits**: Set memory limits, CPU quotas, I/O restrictions&#10;7. **Whitelist APIs**: Only allow access to specific classes/methods&#10;&#10;## Integration with CritterModel&#10;&#10;To integrate sandboxed critters into the main game:&#10;&#10;```java&#10;// In CritterModel.java, modify the add() method or create a new one:&#10;public void addSandboxedCritter(Path critterFile, Point location) throws Exception {&#10;    SecurityHandler.SandboxedCritter sandboxed = &#10;        SecurityHandler.loadCritterFromFile(critterFile);&#10;    &#10;    // Wrap it in an adapter&#10;    Critter adapter = new SandboxedCritterAdapter(sandboxed);&#10;    &#10;    // Add to grid&#10;    grid[location.x][location.y] = adapter;&#10;    info.put(adapter, new PrivateData(location, getRandomDirection()));&#10;}&#10;&#10;// Create an adapter class that implements Critter&#10;class SandboxedCritterAdapter extends Critter {&#10;    private final SecurityHandler.SandboxedCritter sandboxed;&#10;    &#10;    SandboxedCritterAdapter(SecurityHandler.SandboxedCritter sandboxed) {&#10;        this.sandboxed = sandboxed;&#10;    }&#10;    &#10;    @Override&#10;    public Action getMove(CritterInfo info) {&#10;        SecurityHandler.CritterExecutionResult result = &#10;            sandboxed.executeGetMove(info);&#10;        return result.hasError() ? Action.LEFT : result.action;&#10;    }&#10;    &#10;    @Override&#10;    public Color getColor() {&#10;        // Cache or fetch from last execution&#10;        return lastColor;&#10;    }&#10;    &#10;    @Override&#10;    public String toString() {&#10;        return lastDisplay;&#10;    }&#10;}&#10;```&#10;&#10;## Testing&#10;&#10;Run the test suite:&#10;&#10;```bash&#10;cd C:\Users\CodeDay\IdeaProjects\copmsci&#10;.\gradlew build&#10;java -cp &quot;app/build/classes/java/main;app/build/libs/app.jar&quot; compsci.labs.critters.server.SandboxTestRunner&#10;```&#10;&#10;Expected output:&#10;- ✓ Test 1: Normal custom critter executes successfully with state persistence&#10;- ✓ Test 2: Malicious critter executes safely without causing harm&#10;- ✓ Test 3: Game loop integration shows 5 turns of execution with color changes&#10;&#10;## Performance Considerations&#10;&#10;- **Compilation Time**: First load takes ~100-500ms for compilation&#10;- **Execution Time**: Each getMove call should complete in &lt;1ms typically&#10;- **Memory**: Each SandboxedCritter holds a ClassLoader and ExecutorService&#10;- **Recommendation**: Reuse SandboxedCritter instances; don't create/destroy each turn&#10;&#10;## Future Enhancements&#10;&#10;1. **Bytecode Caching**: Cache compiled bytecode to avoid recompilation&#10;2. **Resource Monitoring**: Track CPU/memory usage per critter&#10;3. **Rate Limiting**: Limit compilation requests per player&#10;4. **Code Signing**: Verify critter code signatures&#10;5. **Replay System**: Record and replay critter behaviors for debugging&#10;6. **Hot Reload**: Update critter code without restarting the game&#10;&#10;## Example Custom Critter&#10;&#10;Here's a template players can use:&#10;&#10;```java&#10;import compsci.labs.critters.server.Critter;&#10;import compsci.labs.critters.server.CritterInfo;&#10;import java.awt.Color;&#10;&#10;public class MyAwesomeCritter extends Critter {&#10;    // Your state variables&#10;    private int moveCount = 0;&#10;    &#10;    @Override&#10;    public Action getMove(CritterInfo info) {&#10;        moveCount++;&#10;        &#10;        // Your strategy here&#10;        if (info.frontThreat()) {&#10;            return Action.INFECT;&#10;        } else if (info.getFront() == Neighbor.EMPTY) {&#10;            return Action.HOP;&#10;        } else {&#10;            return Action.RIGHT;&#10;        }&#10;    }&#10;    &#10;    @Override&#10;    public Color getColor() {&#10;        // Your color logic&#10;        return new Color(100, 150, 200);&#10;    }&#10;    &#10;    @Override&#10;    public String toString() {&#10;        // Your display character&#10;        return &quot;A&quot;;&#10;    }&#10;}&#10;```&#10;&#10;## Architecture Decision: Server-Side Execution&#10;&#10;**Decision**: Execute player code on the server, not the client&#10;&#10;**Rationale**:&#10;- ✅ **Security**: Server has full control over sandboxing&#10;- ✅ **Fairness**: All players' code runs in same environment&#10;- ✅ **Cheating Prevention**: Players can't modify client to cheat&#10;- ✅ **Consistency**: Server is source of truth for game state&#10;- ✅ **Simplicity**: Clients just render, don't execute game logic&#10;&#10;**Trade-offs**:&#10;- ❌ Server CPU load increases with player count&#10;- ❌ Must handle malicious code attempts&#10;- ❌ Timeout limits may frustrate players with complex AI&#10;&#10;**Mitigation**:&#10;- Scale horizontally (one server instance per game)&#10;- Clear documentation on execution limits&#10;- Provide profiling tools for players to optimize&#10;&#10;## Conclusion&#10;&#10;This implementation provides a working proof-of-concept for running untrusted player code securely. It successfully:&#10;&#10;1. ✅ Compiles Java source code at runtime&#10;2. ✅ Executes critter methods in isolation&#10;3. ✅ Prevents infinite loops with timeouts&#10;4. ✅ Handles errors gracefully&#10;5. ✅ Integrates with the existing Critter interface&#10;&#10;For production deployment, additional hardening is required, but this demonstrates the core concept is viable.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/compsci/labs/critters/client/BoardSnapshotJson.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/compsci/labs/critters/client/BoardSnapshotJson.java" />
              <option name="updatedContent" value="package compsci.labs.critters.client;&#10;&#10;import compsci.labs.critters.shared.dto.BoardSnapshot;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/** Tiny parser for the hand-built JSON emitted by the server. */&#10;final class BoardSnapshotJson {&#10;    private BoardSnapshotJson() {}&#10;&#10;    static BoardSnapshot parse(String json) {&#10;        // super naive parsing for the sake of this student project&#10;        int width = extractInt(json, &quot;width&quot;);&#10;        int height = extractInt(json, &quot;height&quot;);&#10;        List&lt;BoardSnapshot.Cell&gt; cells = new ArrayList&lt;&gt;();&#10;        String cellsBlock = json.substring(json.indexOf(&quot;[&quot;), json.lastIndexOf(&quot;]&quot;) + 1);&#10;        String[] entries = cellsBlock.split(&quot;\\},\\{&quot;);&#10;        for (String entry : entries) {&#10;            String cleaned = entry.replace(&quot;[&quot;, &quot;&quot;).replace(&quot;]&quot;, &quot;&quot;).replace(&quot;{&quot;, &quot;&quot;).replace(&quot;}&quot;, &quot;&quot;);&#10;            String[] parts = cleaned.split(&quot;,&quot;);&#10;            int x = Integer.parseInt(parts[0].split(&quot;:&quot;)[1]);&#10;            int y = Integer.parseInt(parts[1].split(&quot;:&quot;)[1]);&#10;            String appearance = parts[2].split(&quot;:&quot;)[1].replace(&quot;\&quot;&quot;, &quot;&quot;);&#10;            String colorHex = parts[3].split(&quot;:&quot;)[1].replace(&quot;\&quot;&quot;, &quot;&quot;);&#10;            cells.add(new BoardSnapshot.Cell(x, y, appearance, colorHex));&#10;        }&#10;        return new BoardSnapshot(width, height, cells);&#10;    }&#10;&#10;    private static int extractInt(String json, String key) {&#10;        String needle = &quot;\&quot;&quot; + key + &quot;\&quot;:&quot;;&#10;        int start = json.indexOf(needle) + needle.length();&#10;        int end = json.indexOf(',', start);&#10;        if (end == -1) {&#10;            end = json.indexOf('}', start);&#10;        }&#10;        return Integer.parseInt(json.substring(start, end));&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/compsci/labs/critters/server/SandboxedCritterAdapter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/compsci/labs/critters/server/SandboxedCritterAdapter.java" />
              <option name="updatedContent" value="package compsci.labs.critters.server;&#10;&#10;import java.awt.Color;&#10;import java.awt.Point;&#10;import java.nio.file.Path;&#10;&#10;/**&#10; * Adapter class that wraps a SandboxedCritter and makes it compatible with the CritterModel.&#10; * This allows untrusted player-submitted critters to be used in the game safely.&#10; * &#10; * Usage example:&#10; * &lt;pre&gt;&#10; * // In CritterModel or wherever you add critters:&#10; * Path critterFile = Paths.get(&quot;player_submissions/PlayerCritter.java&quot;);&#10; * SandboxedCritterAdapter adapter = new SandboxedCritterAdapter(critterFile, &quot;PlayerCritter&quot;);&#10; * &#10; * // Add to the game like any other critter&#10; * model.addCustomCritter(adapter, new Point(10, 10));&#10; * &lt;/pre&gt;&#10; */&#10;public class SandboxedCritterAdapter extends Critter {&#10;    private final SecurityHandler.SandboxedCritter sandboxed;&#10;    private final String critterName;&#10;    &#10;    // Cache results from last execution to avoid repeated calls&#10;    private Color cachedColor;&#10;    private String cachedDisplay;&#10;    private boolean initialized;&#10;    &#10;    /**&#10;     * Creates a new adapter from a file path&#10;     */&#10;    public SandboxedCritterAdapter(Path critterFile) throws Exception {&#10;        this.sandboxed = SecurityHandler.loadCritterFromFile(critterFile);&#10;        this.critterName = critterFile.getFileName().toString().replace(&quot;.java&quot;, &quot;&quot;);&#10;        this.cachedColor = Color.BLACK;&#10;        this.cachedDisplay = &quot;?&quot;;&#10;        this.initialized = false;&#10;    }&#10;    &#10;    /**&#10;     * Creates a new adapter from source code&#10;     */&#10;    public SandboxedCritterAdapter(String sourceCode, String className) throws Exception {&#10;        this.sandboxed = SecurityHandler.loadCritterClass(sourceCode, className);&#10;        this.critterName = className;&#10;        this.cachedColor = Color.BLACK;&#10;        this.cachedDisplay = &quot;?&quot;;&#10;        this.initialized = false;&#10;    }&#10;    &#10;    /**&#10;     * Wraps an existing SandboxedCritter&#10;     */&#10;    public SandboxedCritterAdapter(SecurityHandler.SandboxedCritter sandboxed, String name) {&#10;        this.sandboxed = sandboxed;&#10;        this.critterName = name;&#10;        this.cachedColor = Color.BLACK;&#10;        this.cachedDisplay = &quot;?&quot;;&#10;        this.initialized = false;&#10;    }&#10;    &#10;    @Override&#10;    public Action getMove(CritterInfo info) {&#10;        SecurityHandler.CritterExecutionResult result = sandboxed.executeGetMove(info);&#10;        &#10;        if (result.hasError()) {&#10;            // Log the error for debugging&#10;            System.err.println(&quot;[&quot; + critterName + &quot;] Error during getMove: &quot; + &#10;                             result.error.getMessage());&#10;            &#10;            // Return a safe default action&#10;            return Action.LEFT;&#10;        }&#10;        &#10;        // Cache the color and display for later use&#10;        cachedColor = result.color;&#10;        cachedDisplay = result.displayString;&#10;        initialized = true;&#10;        &#10;        return result.action;&#10;    }&#10;    &#10;    @Override&#10;    public Color getColor() {&#10;        // Return cached color from last getMove execution&#10;        // This avoids calling the sandboxed code multiple times per turn&#10;        return cachedColor;&#10;    }&#10;    &#10;    @Override&#10;    public String toString() {&#10;        // Return cached display string from last getMove execution&#10;        return cachedDisplay;&#10;    }&#10;    &#10;    /**&#10;     * Get the name of this critter (for debugging/display)&#10;     */&#10;    public String getCritterName() {&#10;        return critterName;&#10;    }&#10;    &#10;    /**&#10;     * Check if this critter has been successfully initialized&#10;     */&#10;    public boolean isInitialized() {&#10;        return initialized;&#10;    }&#10;    &#10;    /**&#10;     * Clean up resources when this critter is removed from the game&#10;     */&#10;    public void cleanup() {&#10;        sandboxed.close();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/buildSrc/src/main/kotlin/CritterWeaverPlugin.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/buildSrc/src/main/kotlin/CritterWeaverPlugin.kt" />
              <option name="originalContent" value="}&#10;    }&#10;        }&#10;            finalizedBy(weaveTask)&#10;        project.tasks.matching { it.name == &quot;classes&quot; }.configureEach {&#10;&#10;        }&#10;            args = listOf(targetClassFile.absolutePath)&#10;            classpath = mainSourceSet.runtimeClasspath&#10;            mainClass.set(&quot;compsci.labs.critters.weaving.CritterModelWeaver&quot;)&#10;            dependsOn(project.tasks.named(&quot;classes&quot;))&#10;            description = &quot;Injects manager-aware infection guard into CritterModel&quot;&#10;            group = &quot;instrumentation&quot;&#10;        val weaveTask = project.tasks.register(&quot;instrumentCritterModel&quot;, JavaExec::class.java) {&#10;&#10;        val targetClassFile = File(outputDir, &quot;compsci/labs/critters/CritterModel.class&quot;)&#10;        val outputDir = project.layout.buildDirectory.dir(&quot;classes/java/main&quot;).get().asFile&#10;&#10;        val mainSourceSet = sourceSets.findByName(&quot;main&quot;) ?: return&#10;            ?: return&#10;        val sourceSets = project.extensions.findByName(&quot;sourceSets&quot;) as? org.gradle.api.tasks.SourceSetContainer&#10;    private fun configureInstrumentation(project: Project) {&#10;&#10;    }&#10;        }&#10;            configureInstrumentation(project)&#10;        project.afterEvaluate {&#10;    override fun apply(project: Project) {&#10;class CritterWeaverPlugin : Plugin&lt;Project&gt; {&#10;&#10;import java.io.File&#10;import org.gradle.kotlin.dsl.*&#10;import org.gradle.api.tasks.JavaExec&#10;import org.gradle.api.Project&#10;&#10;&#10;" />
              <option name="updatedContent" value="import compsci.labs.critters.weaving.CritterModelWeaver&#10;import org.gradle.api.Plugin&#10;import org.gradle.api.Project&#10;import org.gradle.api.tasks.SourceSetContainer&#10;import org.gradle.kotlin.dsl.configure&#10;import org.gradle.kotlin.dsl.findByType&#10;import org.gradle.kotlin.dsl.named&#10;import org.gradle.kotlin.dsl.register&#10;&#10;class CritterWeaverPlugin : Plugin&lt;Project&gt; {&#10;    override fun apply(project: Project) {&#10;        val sourceSets = project.extensions.findByType&lt;SourceSetContainer&gt;() ?: return&#10;        val main = sourceSets.findByName(&quot;main&quot;) ?: return&#10;&#10;        val instrumentTask = project.tasks.register(&quot;instrumentCritterModel&quot;) {&#10;            group = &quot;instrumentation&quot;&#10;            description = &quot;Injects manager-aware infection guard into CritterModel&quot;&#10;            dependsOn(project.tasks.named(&quot;classes&quot;))&#10;&#10;            val classFile = project.layout.buildDirectory.file(&#10;                &quot;classes/java/main/compsci/labs/critters/CritterModel.class&quot;&#10;            )&#10;&#10;            inputs.files(main.output.classesDirs)&#10;            outputs.file(classFile)&#10;&#10;            doLast {&#10;                val target = classFile.get().asFile&#10;                if (target.exists()) {&#10;                    CritterModelWeaver.instrument(target)&#10;                }&#10;            }&#10;        }&#10;&#10;        project.tasks.named(&quot;classes&quot;).configure {&#10;            finalizedBy(instrumentTask)&#10;        }&#10;        project.tasks.configureEach {&#10;            if (name in setOf(&quot;jar&quot;, &quot;test&quot;, &quot;run&quot;)) {&#10;                dependsOn(instrumentTask)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/buildSrc/src/main/kotlin/compsci/labs/critters/weaving/CritterModelWeaver.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/buildSrc/src/main/kotlin/compsci/labs/critters/weaving/CritterModelWeaver.kt" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="package compsci.labs.critters.weaving&#10;&#10;import org.objectweb.asm.ClassReader&#10;import org.objectweb.asm.ClassWriter&#10;import org.objectweb.asm.Opcodes&#10;import org.objectweb.asm.tree.*&#10;import java.io.File&#10;&#10;object CritterModelWeaver {&#10;    fun instrument(targetClass: File) {&#10;        val bytes = targetClass.readBytes()&#10;        val cr = ClassReader(bytes)&#10;        val node = ClassNode().also { cr.accept(it, 0) }&#10;        instrumentUpdate(node)&#10;        val cw = ClassWriter(ClassWriter.COMPUTE_MAXS or ClassWriter.COMPUTE_FRAMES)&#10;        node.accept(cw)&#10;        targetClass.writeBytes(cw.toByteArray())&#10;    }&#10;&#10;    private fun instrumentUpdate(node: ClassNode) {&#10;        val method = node.methods.firstOrNull { it.name == &quot;update&quot; &amp;&amp; it.desc == &quot;()V&quot; } ?: return&#10;        if (method.instructions.any { it is MethodInsnNode &amp;&amp; it.owner == GLOBAL_STATE &amp;&amp; it.name == &quot;sameManager&quot; }) {&#10;            return&#10;        }&#10;        val skipLabel = findSkipLabel(method) ?: return&#10;        val insertionPoint = findDefenderStoreSuccessor(method) ?: return&#10;        val guard = InsnList().apply {&#10;            add(VarInsnNode(Opcodes.ALOAD, ATTACKER_SLOT))&#10;            add(VarInsnNode(Opcodes.ALOAD, DEFENDER_SLOT))&#10;            add(MethodInsnNode(&#10;                Opcodes.INVOKESTATIC,&#10;                GLOBAL_STATE,&#10;                &quot;sameManager&quot;,&#10;                &quot;(Lcompsci/labs/critters/Critter;Lcompsci/labs/critters/Critter;)Z&quot;,&#10;                false&#10;            ))&#10;            add(JumpInsnNode(Opcodes.IFNE, skipLabel))&#10;        }&#10;        method.instructions.insert(insertionPoint, guard)&#10;    }&#10;&#10;    private fun findSkipLabel(method: MethodNode): LabelNode? {&#10;        val insns = method.instructions.iterator()&#10;        while (insns.hasNext()) {&#10;            val insn = insns.next()&#10;            if (insn is JumpInsnNode &amp;&amp; insn.opcode == Opcodes.IFLT) {&#10;                val prev = insn.previous&#10;                if (prev is LdcInsnNode &amp;&amp; prev.cst == HOP_ADVANTAGE) {&#10;                    return insn.label&#10;                }&#10;            }&#10;        }&#10;        return null&#10;    }&#10;&#10;    private fun findDefenderStoreSuccessor(method: MethodNode): AbstractInsnNode? {&#10;        val insns = method.instructions.iterator()&#10;        while (insns.hasNext()) {&#10;            val insn = insns.next()&#10;            if (insn is VarInsnNode &amp;&amp; insn.opcode == Opcodes.ASTORE &amp;&amp; insn.`var` == DEFENDER_SLOT) {&#10;                return insn.next&#10;            }&#10;        }&#10;        return null&#10;    }&#10;&#10;    private const val GLOBAL_STATE = &quot;compsci/labs/critters/GlobalState&quot;&#10;    private const val HOP_ADVANTAGE = 0.2&#10;    private const val ATTACKER_SLOT = 4&#10;    private const val DEFENDER_SLOT = 10&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>